package main

import (
	"database/sql"
	"fmt"
	"strconv"
	"strings"
	"sync/atomic"
	"testing"
)

// Issue 223 and 236
func TestDecimalInsertByString(t *testing.T) {
	if DecimalInsertByString() != 1 {
		t.Error("Error at DecimalInsertByString")
	}
}

func DecimalInsertByString() int {
	var tableOne string = "godecmalinsertbystringtable"

	db := Createconnection()
	// con := "HOSTNAME=localhost;DATABASE=testdb;PORT=50003;UID=db2inst1;PWD=db2inst1;AUTHENTICATION=SERVER;CurrentSchema=TEST"
	// db, _ := sql.Open("go_ibm_db", con)
	defer db.Close()

	db.Query("DROP table " + tableOne)

	_, err := db.Query("CREATE table " + tableOne + "(id INTEGER NOT NULL GENERATED BY DEFAULT AS IDENTITY, col1  DECIMAL(10,4))")
	if !strings.Contains(fmt.Sprint(err), "did not create a result set") {
		return 0
	}

	sqlstr := "INSERT INTO " + tableOne + " (col1) VALUES(?)"
	qsql := "SELECT col1 FROM " + tableOne + " WHERE id= ?"

	var errcount int64

	// TEST CASE
	valus := []any{"1", "111", "1111", "1.0", "1.1", "1.00", "1.0001", "22e-1", "2e1", nil, "111111.1111", "0"}

	for i, ov := range valus {
		// insert to db
		doDecimalInsertByString(&errcount, db, sqlstr, ov)

		// query from db
		dv, err := doDecimalInsertByStringQuery(db, qsql, i+1)
		if err != nil {
			return 0
		}

		// correlation ov and dv
		vstr, isstr := ov.(string)
		if isstr {
			vfloat, err := strconv.ParseFloat(vstr, 64) // WARN float64 cannot represent higher-precision decimal data
			if err != nil {
				return 0
			}
			if dv != vfloat {
				return 0
			}
		} else {
			if dv != ov {
				return 0
			}
		}

	}

	if errcount > 0 {
		return 0
	}

	db.Query("DROP table " + tableOne)

	return 1
}

func doDecimalInsertByString(ec *int64, db *sql.DB, sqlstr string, value any) {
	_, err := db.Exec(sqlstr, value)
	if err != nil {
		atomic.AddInt64(ec, 1)
	}
}

func doDecimalInsertByStringQuery(db *sql.DB, qsql string, id int) (any, error) {
	rows, err2 := db.Query(qsql, id)
	if err2 != nil {
		return nil, err2
	}

	var f any

	defer rows.Close()
	for rows.Next() {
		err := rows.Scan(&f)
		if err != nil {
			return nil, err
		}
	}

	var value interface{}
	switch data := f.(type) {
	case []byte:
		value2, err := strconv.ParseFloat(string(data), 64)
		if err != nil {
			return nil, err
		}
		value = value2
	case float64:
		value = data
	default:
		value = data
	}

	return value, nil
}
